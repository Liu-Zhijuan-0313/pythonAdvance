"""
 总结垃圾回收的三种机制
    引用计数：(指内存的技术)
    a = [1,2] 引用计数+1 其实是【1,2】列表所在内存的引用+1
    标记清楚:（就是为了解决引用计数的循环引用问题）
    分代回收:（目的是为了确定 对哪些对象进行标记清除）
"""
"""
引用计数+1的情况
    1、对象被创建时，例如a="hello zzy" 
    2、对象被copy引用时，例如 b=a，此时a引用计数+1 
    3、对象被作为参数，传入到一个函数中时 
    4、对象作为一个子元素，存储到容器中时，例如 list=[a,b]
引用计数-1的情况
    1、对象别名被显示销毁，例如 del a 
    2、对象引用被赋予新的对象，例如b=c，此时b引用计数-1（对照引用计数+1的情况下的第二点来看） 
    3、一个函数离开他的作用域，例如函数执行完成，它的引用参数的引用计数-1 
    4、对象所在容器被销毁，或者从容器中删除。

"""
import sys
# print(sys.getrefcount("hello"))
# a = "hello"
# print(sys.getrefcount("hello"))
# b = a
# print(sys.getrefcount("hello"))
# del b, a
# print(sys.getrefcount("hello"))


listA = [x for x in range(1000)]
listB = [x for x in range(1000)]
print(sys.getrefcount(listA))
print(sys.getrefcount(listB))
# listA的引用计数加一，listB不变
listB.append(listA)
print(sys.getrefcount(listA))
print(sys.getrefcount(listB))
# 内存泄露：在程序运行过程中，产生的始终无法访问到的内存地址
# 在回收内存之前 进行标记


"""
标记清除：在进行清除变量之后对每一个删除的对象引用计数-1
如果引用计数变为0 就暂时放入死亡容器
如果引用计数部位0 检测是否引用到了死亡容器容器中对象 
如果引用到了死亡容器对象，将死亡容器对象拿出来放入存活容器
"""

"""
标记清除
第一步查看删除对象后对象所在内存的引用计数，都减去1
【1,2】 计数为 0 死亡容器
【3,4】 计数为 0 死亡容器
【5,6】 计数 为0  死亡容器
【7,8 ，【5,6】】计数为1 存活容器
第二步 遍历存活容器对象 查看是否引用到了死亡容器对象
需要将【5,6】 从死亡容器中拿出放入存活容器

分代收集: 目的是为了确定 对哪些对象进行标记清除
每标记清除一次 称为1代 代数越高 证明存活能力强，执行标记清除频率低
小整数对象与intern机制
某些特定的对象引用计数为0 也不回收，而是放入对象池（用来存储小整数的池子）
有了对象池：系统载频帆的使用小整数时 不需要每次开辟空间和回收空间
"""